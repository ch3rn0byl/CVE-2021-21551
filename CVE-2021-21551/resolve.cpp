#include "resolve.h"

UINT64 resolve::convert(HMODULE hModule, UINT64 BaseAddress, UINT64 Usermode)
{
	Usermode -= reinterpret_cast<UINT64>(hModule);
	Usermode += BaseAddress;

	return Usermode;
}

bool resolve::BaseAddress(const wchar_t* szDriverName, PUINT64 BaseAddress)
{
	const int nSize = 1024 * 2;

	LPVOID lpImageBase[nSize] = { 0 };
	DWORD cbNeeded = 0;

	if (EnumDeviceDrivers(lpImageBase, nSize, &cbNeeded) &&
		cbNeeded < sizeof(lpImageBase))
	{
		wchar_t szDriver[nSize] = { 0 };
		int drivers = cbNeeded / sizeof(lpImageBase[0]);

		for (int i = 0; i < drivers; i++)
		{
			if (GetDeviceDriverBaseName(
				lpImageBase[i],
				szDriver,
				sizeof(szDriver) / sizeof(szDriver[0])
			))
			{
				if (wcscmp(szDriver, szDriverName) == 0)
				{
					*BaseAddress = reinterpret_cast<UINT64>(lpImageBase[i]);
					return true;
				}
			}
		}
	}

	return false;
}

bool resolve::MmPteBase(UINT64 BaseAddress, PUINT64 Result)
{
	HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");
	if (hModule == NULL)
	{
		return false;
	}

	FARPROC MmReturnChargesToLockPagedPool = GetProcAddress(
		hModule,
		"MmReturnChargesToLockPagedPool"
	);
	if (MmReturnChargesToLockPagedPool == NULL)
	{
		return false;
	}

	UINT64 mask = 0xffffffff00000000;
	UINT8 value = 0;
	UINT8 i = 0;
	bool bFound = false;

	do
	{
		value = *reinterpret_cast<PUINT8>(
			reinterpret_cast<PUINT8>(MmReturnChargesToLockPagedPool) + i 
			);
		if (value == 0xe8)
		{
			UINT32 offset = *reinterpret_cast<PUINT32>(
				reinterpret_cast<PUINT8>(MmReturnChargesToLockPagedPool) + i + 1
				);
			offset += 5;

			mask |= offset;

			bFound = true;

			break;
		}
		i++;
	} while (value != 0xc3);

	if (!bFound)
	{
		FreeLibrary(hModule);
		hModule = nullptr;

		return false;
	}

	*Result = convert(
		hModule,
		BaseAddress,
		reinterpret_cast<UINT64>(MmReturnChargesToLockPagedPool) + i + mask
	);

	*Result += 0x13;

	FreeLibrary(hModule);
	hModule = nullptr;

	return true;
}


/// EOF 